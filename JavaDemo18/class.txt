1.类加载的过程
	class字节码加载到JVM内存中
	类的加载指的是将类的.class文件中的而歼之数据读入到内存中，将其放在
运行时数据区的方法区内，然后在堆区创建一个java.lang.class对象，用来封装类
在方法区内的数据结构。类的皆在的最终产品是位于堆区中的class对象，class对象
封装了类在方法去内的数据结构，并且向Java程序员提供了访问的方法区内的数据结构
的接口。
	1）类加载开空间[栈，堆，方法区]
	2）为每个Class创建一个，class管理对象，一个类一个，唯一的，加锁
		class 管理对象就可以直到该类的一切，包括属性，方法，静态都可以
		模板加载到内存中，那么JVM虚拟机可以实例化class对象
		专门负责该类模板，class对象可以直到里面的一切
2.类加载的过程
	加载 链接 初始化
	1）加载：class字节码加载到内存中，分配class管理对象
		加载的机制：JDK 自带的JAVA类 String Math Random...
				  自己编写的类
				  Object /自己写了一个Object  如果机制一样，肯定无法识别
		JAVA中只要该类被加载了，那么就不会再次加载（Static只执行一次）
		JDK中三种类加载器：
				根类加载器/引导类加载器/启动类加载器：BootStrap ClassLoad
						加载 JDK自带的java类（爷爷）
						
				扩展类加载器 Extension  \lib\ext 扩展的类 额外支持的类（父亲）
				
				系统类加载器/应用类加载器 System ClassLoad（儿子）
					加载我们自己编写的类
					
				三个类加载器是继承关系
				
		JDK类加载采用双亲委派模式，什么活都是父亲先干	
					Object自己写的
		先由根类加载器加载，根类发现不能加载，给扩展类加载器，再由系统类加载器加载
						
	2）链接
		1）校验：判断你的class字节码是否正确，有没有书写错误
		2）准备：	静态的资源 static，num先赋予初始值，num=0；		
				final修饰的static不在这一刻开空间
			    final在编译的时候已经开了（src->class）[final最早]
		3）解析：标识符->内存可识别符号 类名 变量名 方法名 接口名 因为->计算机可以识别
		
	3）初始化：
		static修饰初始化 num=5；
	
	总结：类加载：加载（Class 对象，链接（校验，准备static开空间）-> 解析（标识->可识别符号），初始化（static赋初始值）		
						
2。反射（很重要【框架的底层必备】）						
		动态获取java中任何一个类的成员的方法成为反射
		IOC：控制翻转，将程序员对于对象的实例化的过程交给Spring去实例化对象
		Student  类
		Student s1 = new Student(); 程序元手动实例化对象
		javabean java对象的工厂：实例化对象，各种类的对象 IOC		
		创建工厂的时候，怎么知道未来客户需要什么对象，模版是什么	
			反射：运行过程就能知道客户需要实例化类的模板【低耦合】
		
3.用的就是class 管理对象，特效
	class manager = class.forName("全路径类名")	
	class manager = 对象.getClass();
	class manager = 类名.class();	
	1）加载类，运行静态代码块 2）创建类的管理对象
	2）构造方法
		getConstructor(Class...) 获得类的狗仔方法
		无参，有参（多参 形参的类管理对象）
		
4.工厂模式
	简单工厂模式
	静态工厂模式
	javabean工厂，负责实例化对象，对象不要自己new，工厂里面取
	构建对象：单例    工厂
	功能增强：装饰者，代理...
	
	
	
		
		
		
		
		
			
						
						
						
								
					
					
					
					